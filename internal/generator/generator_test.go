package generator

import (
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"testing"

	gen "github.com/MyNihongo/codegen"
	"github.com/MyNihongo/mockgen/internal/loader"
	"github.com/stretchr/testify/assert"
)

const pkgName = `example`

func formatFile(file *gen.File) string {
	res, _ := format.Source([]byte(file.GoString()))
	return string(res)
}

func getWd() string {
	wd, _ := os.Getwd()
	index := strings.LastIndex(wd, "internal")

	return filepath.Join(wd[:index], "examples")
}

func TestGenerateOneService(t *testing.T) {
	const want = `// Code generated by my-nihongo-mockgen. DO NOT EDIT.
package example

import (
	"github.com/stretchr/testify/mock"
	"testing"
)

type fixtureImpl1Service struct {
	ser1 *MockService1_1
}

// AssertExpectations asserts that everything specified with On and Return was in fact called as expected. Calls may have occurred in any order.
func (f *fixtureImpl1Service) AssertExpectations(t *testing.T) {
	f.ser1.AssertExpectations(t)
}

// createFixtureImpl1Service creates a new fixture with all mocks
func createFixtureImpl1Service() (Impl1Service, *fixtureImpl1Service) {
	ser1 := new(MockService1_1)
	fixture := &impl1{ser1: ser1}
	return fixture, &fixtureImpl1Service{ser1: ser1}
}

type MockService1_1 struct {
	mock.Mock
}

func (m *MockService1_1) Boo(param string) (uint64, error) {
	ret := m.Called(param)
	return ret.Get(0).(uint64), ret.Error(1)
}
func (m *MockService1_1) OnBoo(param string) *setup_MockService1_1_Boo {
	call := m.On("Boo", param)
	return &setup_MockService1_1_Boo{call: call}
}

type setup_MockService1_1_Boo struct {
	call *mock.Call
}

func (s *setup_MockService1_1_Boo) Return(param1 uint64, param2 error) {
	s.call.Return(param1, param2)
}
func (m *MockService1_1) Foo(param1 string, param2 int16) string {
	ret := m.Called(param1, param2)
	return ret.String(0)
}
func (m *MockService1_1) OnFoo(param1 string, param2 int16) *setup_MockService1_1_Foo {
	call := m.On("Foo", param1, param2)
	return &setup_MockService1_1_Foo{call: call}
}

type setup_MockService1_1_Foo struct {
	call *mock.Call
}

func (s *setup_MockService1_1_Foo) Return(param1 string) {
	s.call.Return(param1)
}
`
	fixture := []*MockDecl{
		{
			mockNameDecl: &mockNameDecl{
				typeName:      "impl1",
				interfaceName: "Impl1Service",
			},
			fields: []*FieldDecl{
				{
					name: "ser1",
					TypeDecl: loader.NewTypeDecl(
						"github.com/MyNihongo/mockgen/examples/pkg1",
						"Service1_1",
					),
				},
			},
		},
	}

	wd := getWd()
	file, err := GenerateMocks(wd, pkgName, fixture)
	got := formatFile(file)

	assert.Nil(t, err)
	assert.Equal(t, want, got)
}

func TestGenerateOverlappingMocks(t *testing.T) {
	const want = `// Code generated by my-nihongo-mockgen. DO NOT EDIT.
package example

import (
	"github.com/stretchr/testify/mock"
	"testing"
)

type fixtureImpl1Service struct {
	ser2 *MockService2_1
}

// AssertExpectations asserts that everything specified with On and Return was in fact called as expected. Calls may have occurred in any order.
func (f *fixtureImpl1Service) AssertExpectations(t *testing.T) {
	f.ser2.AssertExpectations(t)
}

// createFixtureImpl1Service creates a new fixture with all mocks
func createFixtureImpl1Service() (Impl1Service, *fixtureImpl1Service) {
	ser2 := new(MockService2_1)
	fixture := &impl1{ser2: ser2}
	return fixture, &fixtureImpl1Service{ser2: ser2}
}

type MockService2_1 struct {
	mock.Mock
}

func (m *MockService2_1) Foo(arg1 string, arg2 string) (string, int, error) {
	ret := m.Called(arg1, arg2)
	return ret.String(0), ret.Int(1), ret.Error(2)
}
func (m *MockService2_1) OnFoo(arg1 string, arg2 string) *setup_MockService2_1_Foo {
	call := m.On("Foo", arg1, arg2)
	return &setup_MockService2_1_Foo{call: call}
}

type setup_MockService2_1_Foo struct {
	call *mock.Call
}

func (s *setup_MockService2_1_Foo) Return(param1 string, param2 int, param3 error) {
	s.call.Return(param1, param2, param3)
}

type fixtureImpl2Service struct {
	ser3 *MockService2_1
}

// AssertExpectations asserts that everything specified with On and Return was in fact called as expected. Calls may have occurred in any order.
func (f *fixtureImpl2Service) AssertExpectations(t *testing.T) {
	f.ser3.AssertExpectations(t)
}

// createFixtureImpl2Service creates a new fixture with all mocks
func createFixtureImpl2Service() (Impl2Service, *fixtureImpl2Service) {
	ser3 := new(MockService2_1)
	fixture := &impl2{ser3: ser3}
	return fixture, &fixtureImpl2Service{ser3: ser3}
}
`
	fixture := []*MockDecl{
		{
			mockNameDecl: &mockNameDecl{
				typeName:      "impl1",
				interfaceName: "Impl1Service",
			},
			fields: []*FieldDecl{
				{
					name: "ser2",
					TypeDecl: loader.NewTypeDecl(
						"github.com/MyNihongo/mockgen/examples/pkg2",
						"Service2_1",
					),
				},
			},
		},
		{
			mockNameDecl: &mockNameDecl{
				typeName:      "impl2",
				interfaceName: "Impl2Service",
			},
			fields: []*FieldDecl{
				{
					name: "ser3",
					TypeDecl: loader.NewTypeDecl(
						"github.com/MyNihongo/mockgen/examples/pkg2",
						"Service2_1",
					),
				},
			},
		},
	}

	wd := getWd()
	file, err := GenerateMocks(wd, pkgName, fixture)
	got := formatFile(file)

	assert.Nil(t, err)
	assert.Equal(t, want, got)
}
